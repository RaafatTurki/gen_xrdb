use std::fs::File;
use std::io::prelude::*;
use toml::Value;

fn get_toml_values_from_file(file_name: &str) -> Value {
    let mut file = File::open(file_name).unwrap();
    let mut contents = String::new();
    file.read_to_string(&mut contents).unwrap();
    contents.parse::<Value>().unwrap()
}

fn get_xrdb_value_from_toml_value(v: &Value) -> String {
    let xrdb_v: String;

    if v.is_str() {
        xrdb_v = format!("{}", v.as_str().unwrap());

    } else if v.is_bool() {
        xrdb_v = format!("{}", v);

    } else if v.is_integer() {
        xrdb_v = format!("{}", v);

    } else {
        xrdb_v = String::from("UNSUPPORTED_DATA_TYPE");
        // println!("! {}.{} value is an unsupported data type", mod_name, k);
    }
    xrdb_v
}

fn main() {
    let data = get_toml_values_from_file("xrdb.toml");
    let mut xrdb_content = String::new();

    // generating header
    xrdb_content.push_str(format!("{}\n\n", "! vim: filetype=xdefaults:commentstring=!%s").as_str());

    // generating defines
    for (k, v) in data["defs"].as_table().unwrap() {
        let xrdb_line = format!("{} {} {}\n", "#define", k, get_xrdb_value_from_toml_value(v));
        xrdb_content.push_str(&xrdb_line.as_str());
    }
    xrdb_content.push_str("\n");

    // generating mods
    for (mod_name, table) in data["mods"].as_table().unwrap() {
        
        let final_mod_name;
        if mod_name == "ALL" {
            final_mod_name = "*"
        } else {
            final_mod_name = mod_name.as_str()
        }

        for (k, v) in table.as_table().unwrap() {
            let xrdb_line = format!("{}.{}: {}\n", final_mod_name, k, get_xrdb_value_from_toml_value(v));
            xrdb_content.push_str(&xrdb_line.as_str());
        }
        xrdb_content.push_str("\n");
    }

    // println!("! this file was auto generated by gen_xrdb \n{}", xrdb_content);
    println!("{}", xrdb_content);
}
