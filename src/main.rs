use std::path::Path;
use std::env;

mod utils;

fn main() {
    let arg: Vec<String> = env::args().collect();
    let input_file_path = &arg[1];

    let data = utils::parse_toml_file(input_file_path);
    let path = Path::new(input_file_path);
    let mut xrdb_content = String::new();

    // generating header
    let header_file = data["header_file"].as_str().unwrap();
    let header_file_path = path.parent().unwrap().join(header_file);
    let header = utils::get_file_contents(header_file_path.to_str().unwrap());
    xrdb_content.push_str(format!("{}\n", header).as_str());

    // generating defines
    for (k, v) in data["defs"].as_table().unwrap() {
        let xrdb_line = format!("{} {} {}\n", "#define", k, utils::gen_xrdb_value_from_toml_value(v));
        xrdb_content.push_str(xrdb_line.as_str());
    }
    xrdb_content.push_str("\n");

    // generating mods
    for (mod_name, table) in data["mods"].as_table().unwrap() {

        let final_mod_name;
        if mod_name == "ALL" {
            final_mod_name = "*"
        } else {
            final_mod_name = mod_name.as_str()
        }

        for (k, v) in table.as_table().unwrap() {
            let xrdb_line = format!("{}.{}: {}\n", final_mod_name, k, utils::gen_xrdb_value_from_toml_value(v));
            xrdb_content.push_str(xrdb_line.as_str());
        }
        xrdb_content.push_str("\n");
    }

    // generating footer
    let footer_file = data["footer_file"].as_str().unwrap();
    let footer_file_path = path.parent().unwrap().join(footer_file);
    let footer = utils::get_file_contents(footer_file_path.to_str().unwrap());
    xrdb_content.push_str(format!("{}\n", footer).as_str());

    // println!("! this file was auto generated by gen_xrdb \n{}", xrdb_content);
    println!("{}", xrdb_content);
}
